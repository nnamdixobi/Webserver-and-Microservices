# Webserver-and-Microservices
Online shopping system with a new server component implemented as a RESTful webserver that answers a few requests and microservices for a few functions

Documentation:
This project is designed with a client-server/microservices architecture that utilizes a database. The microservices within this architecture are composed of small, independent services that work together to achieve a specific task. Each service is responsible for a single task, rather than a large, all-encompassing file. The Store Manager project utilizes SQLiteDB as its database and prompts users to connect to their own local host to access the desired information. 
The microservices adhere to the Single Responsibility Principle and clearly state their responsibilities. For example, the ProductPriceUpdateService.java file is solely responsible for updating the price of a specific product based on user input. 

I tested my application by running the webserver class then went to my web browser and typed in “localhost:8500”. After that it pulled up all three requests that we were asked to display which are the product info, order info and user info which I have as product list, order list and user list. As for my microservices I ran my serviceregistry.java file first then ran all my microservices which all worked and said, “Service Published”. You can see this all implemented in the recording I have in my zip file and on the YouTube link I have provided above.

Java Source Code Files:
1.	BasicHttpServer.java: This file creates a basic HTTP server that listens on the port 8500 that we use to run the program and handles requests made to the “/products” context. When a request is received, the handleRequest method is called to send a response back to the client with a message that includes the request URI. Then we have the printRequestInfo method that is used to log information about the incoming request, such as the URI, headers, principal, HTTP method, and querry parameters.
2.	ServiceInfoModel.java: This file is a model class that defines the codes and properties of various services in a distributed system. It contains public static fields representing the different service codes such as PRODUCT_INFO_SERVICE, ORDER_INFO_SERVICE, PRODUCT_PRICE_UPDATE_SERVICE, PRODUCT_QUANTITY_UPDATE_SERVICE, LOGIN_SERVICE, and ORDER_CANCELLATION_SERVICE. These codes can be used to identify and differentiate between different services. Additionally, this model class contains properties for the service host address and service host port, which can be used to specify where a service is hosted and how to connect to it. Overall, the ServiceInfoModel file helps to provide a standardized format for identifying and connecting to services in a distributed system.
3.	ServiceMessageModel: This file is a model for a message sent between services in a service-oriented architecture. It defines several integer codes to represent different types of messages, such as SERVICE_PUBLISH_REQUEST for a request to publish a service to a registry, SERVICE_DISCOVER_REQUEST for a request to discover a service from the registry, and SERVICE_PUBLISH_OK for a response indicating successful publishing of a service. The class also has a data field to hold any additional data that may need to be included in a message. In summary, the ServiceMessageModel class helps facilitate communication between different services in a distributed system.
4.	ServiceRegistry.java: This file is a server program that acts as a registry for microservices. It listens on port 5000 for incoming client requests and accepts them in an infinite loop. Upon receiving a request, it reads the data from the client and deserializes it using the Gson library. If the request is a SERVICE_PUBLISH_REQUEST, the ServiceRegistry adds the new microservice information to the registry HashMap, which is a collection of serviceCode and List<ServiceInfoModel> pairs. If the request is a SERVICE_DISCOVER_REQUEST, the ServiceRegistry searches the registry for the requested serviceCode and returns a random microservice from the List<ServiceInfoModel> associated with that serviceCode. The ServiceRegistry serializes the response as JSON and sends it back to the client. If the requested serviceCode is not found, the ServiceRegistry sends a SERVICE_DISCOVER_NOT_FOUND message. The class is multi-threaded, allowing for multiple clients to connect simultaneously. This server program plays a vital role in service-oriented architecture as it helps clients discover and consume microservices.
5.	WebServer.java:  This file runs on the web server and serves web content to the clients that request it through the internet. It contains the configuration settings and code that handle incoming HTTP requests, determine which files to serve, and send back the appropriate response. Request such as request one order, all order, one product, all product, one user and all users.
6.	OrderLineModel.java: This file represents the order line for in the system which is created when an order is placed by a customer. 
7.	orderModel.java: This represents an order in the store management system with is properties and order lines. It also initializes the orderModel class as an empty list so orderLineModel objects to it as necessary.
8.	ProductModel.java: This represents a model for a product in the store management system and contains four fields that represent the properties of a product.
9.	SQLiteDataAdapter.java: This also implements the DataAccess interface and provides methods for connecting to the database which stores and retrieves order, products, users and information about those products, orders and users.
10.	UserModel.java: This class represents a user in the system and represents the properties of a user in the system such as user ID, username, password and an IsSeller value to indicate if a user is a seller or not.
11.	jsonModel.java: This file is used to represent data in JSON format, as it includes fields for commonly used data types in JSON, such as numbers and strings.
12.	OrderInfoService.java: This file serves as a server for retrieving information about orders in a store. The server listens for incoming requests from clients, and when a request is received, it reads the order ID from the request and uses it to retrieve the corresponding order data from a SQLite database. The order data is then serialized into JSON format using the Google Gson library and sent back to the client as a response. This class also includes a method for registering the service with a registry, so that clients can discover the location of the server. This is achieved by sending a registration request to the registry, containing information about the service code, host address, and port number. 
13.	ProductInfoService.java: This file contains the implementation of a ProductInfoService, which is a server that provides information about a product to clients. The server listens on a specified port and registers with a registry so that clients can find it. When a client connects to the server and sends a product ID, the server retrieves the corresponding product information from a SQLite database using a DataAccess adapter, serializes the information into JSON format using Gson, and sends it back to the client. If the product is not found, the server sends a failure message. The server runs in an infinite loop, serving multiple clients concurrently.
14.	ProductPriceService.java: This file contains the implementation of a product price update service, which listens for incoming client requests on a specified port. The service registers itself with a registry, so clients can discover its location. When a client sends a request to update a product's price, the service reads the request, updates the price in a SQLite database, and sends a response back to the client indicating whether the update was successful or not. The service is designed to work with a specific JSON message format and uses the Google Gson library to convert JSON messages to Java objects and back.
15.	ProductQuantityService.java: This file implements a server for a Product Quantity Service, which accepts client requests over a network socket and updates the quantity of a product in a SQLite database. The server also registers itself with a Registry service, so that clients can locate and connect to it. The file contains two main methods, `main` and `serve`, where the former initializes the server and the latter handles individual client requests. The server listens on a specific port (by default, 5200) for incoming client requests, and updates the product quantity based on the data received from the client. The server responds to the client with a message indicating the success or failure of the update operation. This file relies on several helper classes and libraries, such as `ServiceMessageModel`, `ServiceInfoModel`, and `Gson`, to facilitate communication between the server, client, and Registry services.
16.	UserCancelOrderService.java: This is a Java file for a user cancel order service that communicates with clients using sockets. The program starts a server socket to listen for incoming client requests, and when a request is received, it reads the input message, extracts the necessary data using Gson, and performs a database operation through an adapter. The output of the operation is then sent back to the client using the same socket. The program also registers itself with a registry server, so the clients can discover its location. Overall, this program provides a way for clients to cancel their orders by sending a message to this service.
17.	UserValidService.java: This Java file defines a server that provides a service for checking if a user is valid or not. It listens on a specified port for incoming client requests and responds with whether the user is valid or not based on the information provided by the client. The server also registers itself with a Registry service, so that clients can find and use the UserValidService. The communication between the server and clients is done using JSON data format.
18.	TestClient.java: This file tests the ProductInfo micro service
19.	TestOrder.java: This file tests the OrderInfo micro service
20.	TestProductPrice.java: This file tests the Product Price info microservice
21.	TestProductQuantity.java: This file tests the Product Quantity info microservice
22.	TestUserCancel.java: This file tests the user cancel order microservice.
23.	TestUserValid.java: This file tests the user valid micro service.





